#!/usr/bin/perl

use warnings;
use strict;

use File::Spec::Functions qw(catfile splitpath);
use CPANPLUS::Backend;
use Getopt::Long;
use Pod::Usage;
use English qw(no_match_vars);
use POSIX qw();
use Cwd;

our $VERSION = '0.10';

eval { require CPANPLUS::Dist::Arch; 1; }
    or die <<END_ERR;
cpan2aur: CPANPLUS::Dist::Arch must be installed for this script to work.
END_ERR

## CONSTANTS
##############################################################################

sub PKGBUILD_ERRCODE() { 2 }
sub TOOQUIET_ERRCODE() { 3 }
sub NEEDLWP_ERRCODE()  { 4 }

# should just make these scalars, too... hrmph
sub AUR_LOGIN_URI()    { 'http://aur.archlinux.org/' }
sub AUR_UPLOAD_URI()   { 'http://aur.archlinux.org/pkgsubmit.php' }
sub COOKIE_NAME()      { 'AURSID' }
sub CAT_LIB()          { 10 };

my $TT_DIST_PREFIX = '# CPAN Dist. : ';

my $BAD_LOGIN_MSG  = 'Bad username or password.';
my $NEED_LOGIN_MSG = 'You must create an account before you can upload packages.';
my $PKG_EXISTS_MSG = qr{You are not allowed to overwrite the <b>.*?</b> package.};
my $CFGPATH        = "$ENV{HOME}/.cpan2aur";

my $NEED_LOGIN_ERR = "ERROR\nLogin session was invalid.\n";
my $PKG_EXISTS_ERR = "ERROR\nYou tried to submit a package you do not own.\n";

# Command line flags
my ($DIRECTORY, $VERBOSE, $UPLOAD, $FORCE, $HELP, $MAN, $NAME,
    $TEMPLATE, $REVERSE);

## UTILITY FUNCTIONS
##############################################################################

sub prompt
{
    local $OUTPUT_AUTOFLUSH = 1;
    print shift, q{ };
    my $line = <STDIN>;
    chomp $line;
    return $line;
}

sub prompt_yn
{
    die 'Invalid arguments to prompt_yn' unless ( @_ == 2 );
    my ($message, $default) = @_;

    my $first = lc substr $default, 0, 1;
    $default = ( $first eq 'y' ? 1 : $first eq 'n' ? 0 : 1 );
    
    $message .= q{ } . ( $default ? '[Yn]' : '[yN]' );

    my $answer;
    QUESTION: {
        $answer = prompt( $message );

        return $default if ( length $answer == 0 );
        redo QUESTION unless $answer =~ /\A[yYnN]/;
    }

    return 0 if $answer =~ /\A[nN]/;
    return 1;
}

sub prompt_password
{
    my $termios = POSIX::Termios->new;
    $termios->getattr( 0 ); # STDIN

    my $c_lflag = $termios->getlflag;
    $termios->setlflag( $c_lflag & ~POSIX::ECHO );
    $termios->setattr( 0, POSIX::TCSANOW );

    my $passwd = prompt( 'Password:' );

    $termios->setlflag( $c_lflag );
    $termios->setattr( 0, POSIX::TCSANOW );

    print "\n";

    return $passwd;
}

sub pkgdir
{
    my $dist_obj = shift;
    return $dist_obj->status->pkgname;
}

sub pkgdir_file
{
    my ($dist_obj, $file) = @_;
    return catfile( pkgdir( $dist_obj ), $file );
}

sub find_module
{
    my $mod_or_dist = shift;
    our $CB ||= CPANPLUS::Backend->new;
    print "Looking up module for $mod_or_dist on CPAN...\n";
    my $modobj = $CB->parse_module( module => $mod_or_dist );
    # TODO: die if module not found?
    return $modobj;
}

# Check if a file exists, if so offer to delete it.
# Return 1 if the file doesn't exist or it does and was deleted.
#        0 if the file existed and the user wanted to keep it.
sub confirm_overwrite
{
    my ($file_path) = @_;

    return 1 unless ( -f $file_path );

    # User wants us to force deletions...
    if ( $FORCE ) {
        unlink $file_path or die qq{failed to "rm $file_path": $!};
        return 1;
    }

    # Keep asking until we get a yes, no, or blank answer...
        my $answer = prompt_yn( "$file_path already exists, overwrite?" => 'yes' );

    unlink $file_path or die qq{Failed to "rm $file_path": $!};
    return 1;
}

sub new_pkgdir_file
{
    my ($distobj, $pkgfile) = @_;

    my $pkgdir    = pkgdir ( $distobj );
    my $file_path = pkgdir_file( $distobj, $pkgfile );

    if ( -f $file_path ) {
        # If the pkgfile already exists, offer to overwrite.
        return 0 unless confirm_overwrite( $file_path );
        return 1;
    }

    unless ( -d $pkgdir ) {
        mkdir $pkgdir or die qq{failed to "mkdir $pkgdir": $!};
    }

    return 1;
}

sub create_dist_arch
{
    my ($mod_obj, $target) = @_;

    $mod_obj->fetch  ( verbose => 0 ) or return 0;
    $mod_obj->extract( verbose => 0 ) or return 0;

    my $dist_obj = $mod_obj->dist( target  => $target,
                                   format  => 'CPANPLUS::Dist::Arch',
                                   args    => { verbose => $VERBOSE,
                                                pkg     => 'src',
                                                destdir => getcwd() });
    return $dist_obj;
}

## AUR PACKAGE UPLOAD
##############################################################################

# Loads the last login username & session ID used.
sub _load_last_login
{
    return () unless ( -f $CFGPATH );

    die q{Please 'chmod 600 ~/.cpan2aur', it is not readable}
        unless ( -r $CFGPATH );

    open my $cfgfile, q{<}, $CFGPATH or die "open $CFGPATH: $!";
    my ($user, $sid) = split /:/, <$cfgfile>;
    close $cfgfile;

    return () unless ( $user && $sid && $sid =~ /\A[A-F0-9]+\Z/ );

    # If the user specified a --name flag, make sure it matches the cached...
    return () unless ( lc $user eq lc $NAME );

    chomp $sid;
    return ($user, $sid);
}

# Save the username & session ID for later.
sub _save_last_login
{
    my ($username, $sid) = @_;

    # Set umask to keep this file private...
    my $oldmask = umask 0077;
    $username   = lc $username;

    open my $cfgfile, '>', $CFGPATH or die "open $CFGPATH: $!";
    print $cfgfile "$username:$sid\n";
    close $cfgfile or die "close $CFGPATH: $!";

    umask $oldmask;
    return;
}

# Login to AUR to get a fresh session ID cookie.
# Params:  $ua - LWP::UserAgent object
#                (this gets a new cookie jar with a new session cookie)
#          $username - Username to login AUR.
#          $password - Password to login AUR.
# Returns: a new session ID
sub _new_login_sid
{
    my ($ua, $username, $passwd) = @_;

    # Get a fresh session ID cookie...
    $ua->cookie_jar( HTTP::Cookies->new() );
    my $resp = $ua->post( AUR_LOGIN_URI,
                          [ user        => $username,
                            passwd      => $passwd,
                            remember_me => 1, # probably not needed
                           ] );

    # Check for problems...
    die "Bad username or password\n"
        if ( $resp->content =~ /$BAD_LOGIN_MSG/ );

    die "Error with AUR login, expected status code 302.\nGot status: ",
        $resp->status_line if !( $resp->code == 302  && !$resp->is_success );

    my $sid;
    $ua->cookie_jar()->scan( sub { $sid = $_[2] if $_[1] eq COOKIE_NAME; } );

    die "ERROR Login did not supply us with an AURSID cookie\n"
        unless ( $sid );

    return $sid;
}

# Params: $sid - Session ID to login the AUR with.
# Returns: A new HTTP::Cookies object with an AUR session ID cookie.
sub _mk_session_cookie
{
    my ($sid) = @_;

    my %cookies = ( COOKIE_NAME() => $sid,
                    AURLANG       => 'en', );

    my $cookie_obj = HTTP::Cookies->new();
    for my $name ( keys %cookies ) {
        $cookie_obj->set_cookie( q{}, $name, $cookies{$name},
                                 q{/}, 'aur.archlinux.org' );
    }

    return $cookie_obj;
}

# Params: $ua - LWP::UserAgent object, should have SID cookie in it.
#         $pkg_path - Path of source package file to upload.
sub _post_upload
{
    my ($ua, $pkg_path) = @_;

    my $resp = $ua->post( AUR_UPLOAD_URI,
                          'Content-Type' => 'form-data',
                          'Content'      => [ category  => CAT_LIB(),
                                              submit    => 'Upload',
                                              pkgsubmit => 1,
                                              pfile     => [ $pkg_path ],
                                             ] );

    # We get a 302 Moved HTTP status code on success and when uploading a package
    # that we own, if the package file is older and ignored...
    return if ( $resp->code() == 302 );
    
    die "Error when uploading file, got http status ", $resp->status_line
        unless ( $resp->is_success );

    die $NEED_LOGIN_ERR if ( $resp->content =~ /$NEED_LOGIN_MSG/ );
    die $PKG_EXISTS_ERR if ( $resp->content =~ /$PKG_EXISTS_MSG/ );

    return;
}

# Make sure the libwww modules we need are loaded, if not offer to install
# as a package.
sub _load_web_modules
{
    my $loaded = eval {
        require LWP::UserAgent;
        require HTTP::Cookies;
        1;
    };

    unless ( $loaded ) {
        my $answer = 1;

        # Force flag will install perl-libwww without asking...
        unless ( $FORCE ) {
            $answer = prompt_yn( <<'END_PROMPT' => 'yes' );
You need the perl-libwww package installed to upload to the AUR.
Do you want to install it now?
END_PROMPT
            $answer = ($answer !~ /\A[nN]/ );
        }

        exit NEEDLWP_ERRCODE unless ( $answer );

        my $oldcwd = getcwd();
        my $modobj = find_module( 'LWP' );
        $modobj->install( type => 'install', format => 'CPANPLUS::Dist::Arch', );
        chdir $oldcwd;

        # Try again after we install it!
        $loaded = eval {
            require LWP::UserAgent;
            require HTTP::Cookies;
            1;
        };

        die "Unknown error, unable to load LWP::UserAgent and HTTP::Cookies"
            unless $loaded;
    }

    return;
}

# Upload a package file to the AUR, handle all user interaction, loading old
# session ID's from our saved file, etc logic.
sub upload_pkgfile
{
    my ($pkg_path) = @_;

    _load_web_modules();

    print "Uploading $pkg_path to AUR...\n";

    my ($username, $sid) = _load_last_login();
    $username ||= $NAME || prompt( 'Username:' );

    my $ua = LWP::UserAgent->new();
    # First try to reuse an old Session ID...
    if ( $sid ) {
        print "Sending package as $username... ";
        $ua->cookie_jar( _mk_session_cookie( $sid ));
        eval { _post_upload( $ua, $pkg_path ) };
        unless ( $EVAL_ERROR ) {
            print "ok\n";
            return;
        }

        # Fall through to get a new session ID if we just need to re-login...
        die $EVAL_ERROR unless ( $EVAL_ERROR =~ /$NEED_LOGIN_ERR/ );

        print "old session ID failed. Starting new session.\n";
    }

    my $passwd = prompt_password();

    # Retrieve a new session and save it...
    $sid = _new_login_sid( $ua, $username, $passwd );
    _save_last_login( $username, $sid );

    print "Sending package as $username...\n";
    _post_upload( $ua, $pkg_path );
    print "Success.\n";

    return;
}

sub upload_pkgdir
{
    my ($pkgdir) = @_;

    # Hopefully this is a package directory...
#     printf "Uploading package from %s directory...\n",
#         ( $pkgdir eq q{.} ? 'current' : $pkgdir );
    chdir $UPLOAD unless ( $pkgdir eq q{.} );

    # Convert template to PKGBUILD if one exists in the directory.
    tt_to_pkgbuild() if ( -f 'PKGBUILD.tt' );

    die <<'END_ERR' unless ( -f 'PKGBUILD' );
There is no PKGBUILD in the directory and no file or module names specified on
the command line.  Unable to upload anything.
END_ERR

    print "Creating source package with makepkg...\n";
    my $output = `makepkg --source --force --clean 2>&1`;

    # We can only parse the output of makepkg to find the filename...
    my @pkginfo = $output =~ /Making package: ([\w-]+) ([\d.-]+)/
        or die "ERROR makepkg returned unexpected output";

    my $pkgfile = ( join q{-}, @pkginfo ) . '.src.tar.gz';

    upload_pkgfile( $pkgfile );
    return;

}

sub upload_thing
{
    my ($thing) = @_;

    if ( -d $thing ) {
        upload_pkgdir( $thing );
        return;
    }

    if ( -f $thing ) {
        die <<"END_ERR" unless ( $thing =~ /[.]src[.]tar[.]gz$/ );
$thing file is not named like a source package file.
END_ERR
        upload_pkgfile( $thing );
        return;
    }

    # Last resort is that argument is a module...
    my $dist_obj = create_dist_arch( $thing );
    upload_pkgfile( $dist_obj->status->dist );

    return;
}

## PKGBUILD TEMPLATES
##############################################################################

# Creates a new template file that matches C::D::A's default template in a
# source package dir.
sub new_tt_file
{
    my ($dist_obj) = @_;
    return unless new_pkgdir_file( $dist_obj, 'PKGBUILD.tt' );

    open my $templ_file, '>', pkgdir_file( $dist_obj, 'PKGBUILD.tt' )
        or die "open PKGBUILD.tt failed: $!";

    # Insert the distribution name in the comments... used in tt_to_pkgbuild().
    print $templ_file $TT_DIST_PREFIX, $dist_obj->parent->package_name, "\n";
    print $templ_file $dist_obj->get_pkgbuild_templ;

    close $templ_file or die "close PKGBUILD.tt failed: $!";
}

# Take a PKGBUILD in the _current_dir_ and create a template out of it for
# future awesomeness.
sub pkgbuild_to_tt
{
    # Handle missing or existing files...
    die <<'END_ERR' unless ( -f 'PKGBUILD' );
There is no PKGBUILD in the current directory that we can reverse into a
template.
END_ERR

    return unless confirm_overwrite( 'PKGBUILD.tt' );

    open my $pkgbuild_file, '<', 'PKGBUILD' or die "open PKGBUILD: $!";
    my $pkgbuild_txt = do { local $/; <$pkgbuild_file> }; # slurp!
    close $pkgbuild_file;

    # Find the distribution name so we can look it up when we convert the template
    # to the PKGBUILD in tt_to_pkgbuild()...
    my ($distname) =
        $pkgbuild_txt =~ m{^ source = \s* [^\n]* / ( [-\w]+ ) -\d }xms;
    
    die "ERROR Failed to determine the distribution name from the ",
        "existing PKGBUILD\n" unless ( $distname );

    # Replace all bash variables values we can with template values...
    my $var_match = join '|',
        qw/ pkgname pkgver pkgdesc url source md5sums source /;

    $pkgbuild_txt =~ s{($var_match) = \s* ["]    .*? [^\\] ["]    }
                      {$1="\[% $1 \%]"}gxms;
    $pkgbuild_txt =~ s{($var_match) = \s* [']    .*?       [']    }
                      {$1='\[% $1 \%]'}gxms;
    $pkgbuild_txt =~ s{($var_match) = \s* [(]['] .*?       ['][)] }
                      {$1=('\[% $1 \%]')}gxms;
    $pkgbuild_txt =~ s{($var_match) = \s* [(]["] .*? [^\\] ["][)] }
                      {$1=("\[% $1 \%]")}gxms;

    # Depends are different, remove the quotes from inside the parenthesis.
    # Also try to preserve non-perl dependencies...
    $pkgbuild_txt =~ s{ ^depends = \s* [(] (.*?) [)] }
                      { ( sprintf q{depends=([%% depends %%]%s)},
                          map { $_ ? " $_" : q{} }
                          join q{ }, grep { !/perl/ } split /\s+/, $1 ) }xmse;

    # Also replace _DISTDIR or DIST_DIR if we are creating a template from
    # a C::D::A generated PKGBUILD...
    $pkgbuild_txt =~ s{(DIST|_DIST)DIR=".*?"}{DIST_DIR="\${srcdir}/[% distdir %]"};
    $pkgbuild_txt =~ s{\$_DISTDIR}{\$DIST_DIR}g;
    # Change _DISTDIR for backwards compatibility...

    open my $templ_file, '>', 'PKGBUILD.tt' or die "open PKGBUILD.tt: $!";
    print $templ_file $TT_DIST_PREFIX, $distname, "\n";
    print $templ_file $pkgbuild_txt;
    close $templ_file;

    print "Reverse-engineered PKGBUILD to PKGBUILD.tt successfully\n";

    return;
}

# Fills a template and prints it to a PKGBUILD file.
# Returns: A CPANPLUS::Dist::Arch object of the PKGBUILD's package.
sub tt_to_pkgbuild
{
    print "Converting PKGBUILD.tt template to PKGBUILD...\n";
    return unless confirm_overwrite( 'PKGBUILD' );

    open my $templ_file, '<', 'PKGBUILD.tt' or die "open PKGBUILD.tt: $!";
    my ($distname) = ( scalar <$templ_file> ) =~ /^$TT_DIST_PREFIX(.*)$/;
    die qq{ERROR "$TT_DIST_PREFIX" line is missing from the
PKGBUILD.tt template.  This template file may not have been generated by
cpan2aur.

In order to use this .tt file with cpan2aur, insert the CPAN distribution's
name into the file prefixed with the above comment in quotes.
} unless $distname;
    
    my $templ_text = do { local $/; <$templ_file> };
    close $templ_file or die "close PKGBUILD.tt: $!";

    # Create a CPANPLUS::Dist::Arch object to convert the template to PKGBUILD
    my $modobj  = find_module( $distname );
    my $distobj = create_dist_arch( $modobj => 'prepare' );

    $distobj->set_pkgbuild_templ( $templ_text );
    $distobj->create_pkgbuild( q{.} );

    return $distobj;
}

## SCRIPT START
##############################################################################

GetOptions( 'directory' => \$DIRECTORY,
            'verbose'   => \$VERBOSE,
            'reverse'   => \$REVERSE,
            'upload:s'  => \$UPLOAD,
            'force'     => \$FORCE,
            'name=s'    => \$NAME,
            'man'       => \$MAN,
            'help'      => \$HELP,
           );

$VERBOSE //= 0;

pod2usage( -message => 'The -r[everse] flag must be used by itself.' )
    if ( $REVERSE && ( $UPLOAD || $DIRECTORY ));

pod2usage( -verbose => 1 ) if ( $HELP );
pod2usage( -verbose => 2 ) if ( $MAN  );

if ( $REVERSE ) {
    pkgbuild_to_tt();
    exit 0;
}

# If no arguments are given to upload default to the current directory.
if ( defined $UPLOAD && !@ARGV ) {
    push @ARGV, ( length $UPLOAD ? $UPLOAD : q{.} );
}

pod2usage( -verbose => 0 ) unless ( @ARGV );

ARG_LOOP:
for my $arg ( @ARGV ) {
    if ( defined $UPLOAD ) {
        upload_thing( $arg );
        next ARG_LOOP;
    }

    my $modobj = find_module( $arg );

    unless ( $modobj ) {
        warn "cpan2aur: Failed to find a module named $arg\n";
        next MODULE_LOOP;
    }

    my $distobj = create_dist_arch( $modobj, ( $DIRECTORY
                                               ? 'prepare' : 'create' ))
        or die 'ERROR Failed to create CPANPLUS::Dist::Arch object';

    if ( defined $DIRECTORY ) {
        new_tt_file( $distobj );
        next ARG_LOOP;
    }

    print "Created source package file ", $distobj->status->dist, ".\n";
}

__END__

=head1 NAME

cpan2aur - AUR packager utility for CPAN perl modules

=head1 SYNOPSIS

cpan2aur [-v -f] --directory Module::Name [Module::Name:Two] 

cpan2aur [-v -f] --upload [Module::Name file-name.src.tar.gz /pkg/dir/]

cpan2aur [-v -f] -r

cd <package-directory>; cpan2aur [--reverse or --upload]

 -h, --help            Display this usage message.
 -m, --man             Display full help manual page.
 -v, --verbose         Allow CPANPLUS to be more verbose.
 -f, --force           Overwrite files without asking.

 -d, --directory       Create a source package directory with a standard
                       PKGBUILD.tt template file.
 -r, --reverse         Convert a PKGBUILD in the current directory to a
                       template file (PKGBUILD.tt).
 -u, --upload  [dir]   Upload the generated source package to the AUR.
              [file]   * If a dir is specified cd to that dir and
            [module]     convert PKGBUILD.tt to a PKGBUILD to a
                         source package, then upload it.
                       * If a file is specified, upload it if it appears
                         to be a source package.
                       * If a module is specified, package and upload it.
                       * If nothing is specified, act upon the current
                         directory.
 -n, --name <username> Specify a different username to login to the AUR,
                       instead of the last one used.

 (Unlike GNU options, single-letter options need their own hyphens
  example: -u -d)

=head1 DESCRIPTION

This is a utility made for creating and uploading perl packages for
the AUR (Archlinux User Repository).  cpan2aur's simplest usage
creates AUR source packages in the current directory.

With the I<-d> or I<--directory> flags cpan2aur will create a
directory to contain the source package and generate a C<PKGBUILD.tt>
template inside it.

Templates are a powerful way to make maintaining packages on the AUR
easier.  Most of the time you will not have to update the PKGBUILD
template you will just use the I<--upload> flag on a source package
directory containing a template.

With the I<-u> or I<--upload> flag cpan2aur will upload a source
package to the AUR.  It will try to Do The Right Thing (tm) for
arguments given to the flag.  We store previous logins inside the file
C<~/.cpan2aur>.  The last username that was used will be retried.  To
use a different username, delete the C<~/.cpan2aur> file.

=head1 SEE ALSO

=over 4

=item * L<CPANPLUS::Dist::Arch>

=item * L<http://aur.archlinux.org>

=back

=head1 AUTHOR

Justin Davis C<< <juster at cpan dot org> >>

=head1 COPYRIGHT & LICENSE

Copyright 2010 Justin Davis, all rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut
