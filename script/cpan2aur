#!/usr/bin/perl

use warnings;
use strict;

use File::Spec::Functions qw(catfile splitpath);
use CPANPLUS::Backend;
use Term::ReadLine;
use Getopt::Long;
use English qw(no_match_vars);
use Pod::Usage;
use 5.010;
use Cwd;

our $VERSION = '0.10';

eval { require CPANPLUS::Dist::Arch; 1; }
    or die <<END_ERR;
cpan2aur: CPANPLUS::Dist::Arch must be installed for this script to work.
END_ERR

## CONSTANTS
##############################################################################

sub PKGBUILD_ERRCODE() { 2 }
sub TOOQUIET_ERRCODE() { 3 }
sub NEEDLWP_ERRCODE()  { 4 }

# should just make these scalars, too... hrmph
sub AUR_LOGIN_URI()    { 'http://aur.archlinux.org/' }
sub AUR_UPLOAD_URI()   { 'http://aur.archlinux.org/pkgsubmit.php' }
sub COOKIE_NAME()      { 'AURSID' }
sub CAT_LIB()          { 10 };

my $TT_DIST_PREFIX = '# CPAN Dist. : ';

my $BAD_LOGIN_MSG  = 'Bad username or password.';
my $NEED_LOGIN_MSG = 'You must create an account before you can upload packages.';
my $PKG_EXISTS_MSG = qr{You are not allowed to overwrite the <b>.*?</b> package.};
my $CFGPATH        = "$ENV{HOME}/.cpan2aur";

my $NEED_LOGIN_ERR = "ERROR\nLogin session was invalid.\n";
my $PKG_EXISTS_ERR = "ERROR\nYou tried to submit a package you do not own.\n";

## COMMAND LINE ARGUMENTS
##############################################################################

my ($DIRECTORY, $VERBOSE, $UPLOAD, $QUIET, $FORCE, $HELP, $MAN, $NAME,
    $TEMPLATE, $REVERSE);

GetOptions( 'directory' => \$DIRECTORY,
            'template'  => \$TEMPLATE,
            'verbose'   => \$VERBOSE,
            'reverse'   => \$REVERSE,
            'upload:s'  => \$UPLOAD,
            'force'     => \$FORCE,
            'quiet'     => \$QUIET,
            'name=s'    => \$NAME,
            'man'       => \$MAN,
            'help'      => \$HELP,
           );

pod2usage( -message => 'We cannot be both verbose and quiet!',
           -verbose => 0,
           -retval  => 1 ) if ( $VERBOSE && $QUIET);

pod2usage( -verbose => 1 ) if ( $HELP );

## AUR PACKAGE BUILDING
##############################################################################

sub msg
{
    return if $QUIET;

    if ( @_ == 2 ) {
        my $fh = shift;
        print $fh @_;
        return;
    }

    print @_;
}

# Check if a file exists, if so offer to delete it.
# Return 1 if the file doesn't exist or it does and was deleted.
#        0 if the file existed and the user wanted to keep it.
sub confirm_overwrite
{
    my ($file_path) = @_;

    return 1 unless ( -f $file_path );

    # User wants us to force deletions...
    if ( $FORCE ) {
        unlink $file_path or die qq{failed to "rm $file_path": $!};
        return 1;
    }

    exit PKGBUILD_ERRCODE if $QUIET; # exit program with error if we're quiet

    # Keep asking until we get a yes, no, or blank answer...
    USER_QUESTION:
    {
        my $answer = prompt( "$file_path already exists, overwrite? [yN]");
        $answer ||= q{n};
        redo USER_QUESTION unless $answer =~ /\A[yn]/i;
 
        return 0 if $answer =~ /\An/i;
    }

    msg( "Overwriting $file_path... " );
    unlink $file_path or die qq{failed to "rm $file_path": $!};
    msg( "ok\n" );
    return 1;
}

sub check_pkgdir_file
{
    my ($distobj, $pkgfile) = @_;
    my $pkgdir    = $distobj->status->pkgname;
    my $file_path = "$pkgdir/$pkgfile";

    if ( -f $file_path ) {
        # If the pkgfile already exists, offer to overwrite.
        return 0 unless confirm_overwrite( $file_path );
    }
    else {
        unless ( -d $pkgdir ) {
            mkdir $pkgdir or die qq{failed to "mkdir $file_path": $!};
        }
        msg( "Creating $file_path.\n" );
    }

    return 1;
}

sub create_aurpkgdir
{
    my $dist_obj = shift;
    my $pkgname = $dist_obj->status->pkgname;

    return unless check_pkgdir_file( $dist_obj, 'PKGBUILD' );
    
    $dist_obj->create_pkgbuild( $pkgname );
    return;
}

sub hide_output_of
{
    my $code_ref = shift;

    open my $stdout_dup, '>&STDOUT' or die "duping STDOUT: $!";
    open my $stderr_dup, '>&STDERR' or die "duping STDOUT: $!";
    close STDOUT;
    close STDERR;

    my $retval = eval { $code_ref->() };

    # Restore output...
    open STDOUT, ">&", $stdout_dup or die "resuming STDOUT: $!";
    open STDERR, ">&", $stderr_dup or die "resuming STDERR: $!";

    die if ( $EVAL_ERROR );
    return $retval;
}

sub create_dist_arch
{
    my ($mod_obj, $target) = @_;

    my $creator = sub {
        # Always hide fetching and extracting... they ugly.
        hide_output_of( sub {
            $mod_obj->fetch( verbose => 0 ) && $mod_obj->extract( verbose => 0 )
        }) or return 0;

        $mod_obj->dist( target  => $target,
                        format  => 'CPANPLUS::Dist::Arch',
                        args    => { verbose => !$QUIET || $VERBOSE,
                                     pkg     => 'src',
                                     destdir => getcwd() })
    };

    return ( $QUIET ? hide_output_of( $creator ) : $creator->() );
}

## AUR PACKAGE UPLOAD
##############################################################################

sub load_last_login
{
    return () unless ( -e $CFGPATH );

    die q{Please 'chmod 600 ~/.cpan2aur', it is not readable}
        unless ( -r $CFGPATH );

    open my $cfgfile, '<', $CFGPATH or die "open $CFGPATH: $!";
    my ($user, $sid) = split ':', <$cfgfile>;
    close $cfgfile;

    return () unless ( $user && $sid && $sid =~ /^[A-F0-9]+$/m );

    chomp $sid;
    return ($user, $sid);
}

sub save_last_login
{
    my ($username, $sid) = @_;

    # Set umask to keep this file private...
    my ($oldmask, $found) = (umask 0077, 0);
    $username = lc $username;

    open my $cfgfile, '>', $CFGPATH or die "open $CFGPATH: $!";
    print $cfgfile "$username:$sid\n";
    close $cfgfile or die "close $CFGPATH: $!";

    umask $oldmask;
    return;
}

sub new_login_sid
{
    my ($ua, $username, $passwd) = @_;

    # Get a fresh session ID cookie...
    $ua->cookie_jar( HTTP::Cookies->new() );
    my $resp = $ua->post( AUR_LOGIN_URI,
                          [ user        => $username,
                            passwd      => $passwd,
                            remember_me => 1, # probably not needed
                           ] );

    # Check for problems...
    die "Bad username or password\n"
        if ( $resp->content =~ /$BAD_LOGIN_MSG/ );

    die "Error with AUR login, expected status code 302.\nGot status: ",
        $resp->status_line if !( $resp->code == 302  && !$resp->is_success );

    my $sid;
    $ua->cookie_jar()->scan( sub { $sid = $_[2] if $_[1] eq COOKIE_NAME; } );

    die "ERROR Login did not supply us with an AURSID cookie\n"
        unless ( $sid );

    return $sid;
}

sub mk_session_cookie
{
    my ($sid) = @_;

    my %cookies = ( COOKIE_NAME() => $sid,
                    AURLANG       => 'en', );

    my $cookie_obj = HTTP::Cookies->new();
    for my $name ( keys %cookies ) {
        $cookie_obj->set_cookie( q{}, $name, $cookies{$name},
                                 q{/}, 'aur.archlinux.org' );
    }

    return $cookie_obj;
}

sub post_upload
{
    my ($ua, $pkg_path) = @_;

    my $resp = $ua->post( AUR_UPLOAD_URI,
                          'Content-Type' => 'form-data',
                          'Content'      => [ category  => CAT_LIB(),
                                              submit    => 'Upload',
                                              pkgsubmit => 1,
                                              pfile     => [ $pkg_path ],
                                             ] );

    # We get a 302 Moved HTTP status code on success and when uploading a package
    # that we own if the package file is older and ignored...
    return if ( $resp->code() == 302 );
    
    die "Error when uploading file, got http status ", $resp->status_line
        unless ( $resp->is_success );

    die $NEED_LOGIN_ERR if ( $resp->content =~ /$NEED_LOGIN_MSG/ );
    die $PKG_EXISTS_ERR if ( $resp->content =~ /$PKG_EXISTS_MSG/ );
}

sub prompt
{
    exit TOOQUIET_ERRCODE if $QUIET;
    local $OUTPUT_AUTOFLUSH = 1;
    print shift, q{ };
    return Term::ReadLine->new( 'cpan2aur' )->readline();
}

sub upload_to_aur
{
    my ($pkg_path) = @_;

    msg "Uploading $pkg_path to AUR...\n";

    my ($username, $sid) = $NAME || load_last_login() || prompt( 'Username:' );

    my $ua = LWP::UserAgent->new();
    # First try to reuse an old Session ID...
    if ( $sid ) {
        msg( "Sending package as $username... " );
        $ua->cookie_jar( mk_session_cookie( $sid ));
        eval { post_upload( $ua, $pkg_path ) };
        unless ( $EVAL_ERROR ) {
            msg( "ok\n" );
            return;
        }

        # Fall through to get a new session ID if we just need to re-login...
        die $@ unless ( $EVAL_ERROR =~ /$NEED_LOGIN_ERR/ );

        msg( "old session ID failed. Starting new session.\n" );
    }

    my $passwd = prompt( 'Password:' );

    # Retrieve a new session and save it...
    $sid = new_login_sid( $ua, $username, $passwd );
    save_last_login( $username, $sid );
    msg( "ok\n" );

    msg( "Sending package as $username... " );
    post_upload( $ua, $pkg_path );
    msg( "ok\n" );

    return;
}

sub load_web_modules
{
    my $loaded = eval {
        require LWP::UserAgent;
        require HTTP::Cookies;
        1;
    };

    unless ( $loaded ) {
        my $answer = 1;

        # Force flag will install perl-libwww without asking...
        unless ( $FORCE ) {
            $answer =
                prompt( 'You need the perl-libwww package installed to upload packages
Do you want to install it now? [Yn]');
            $answer = ($answer !~ /\A[nN]/ );
        }

        exit NEEDLWP_ERRCODE unless ( $answer );

        my $oldcwd = getcwd();
        my $cb     = CPANPLUS::Backend->new;
        my $modobj = $cb->module_tree( 'LWP' );
        $modobj->install( type => 'install', format => 'CPANPLUS::Dist::Arch', );
        chdir $oldcwd;

        # Try again after we install it!
        $loaded = eval {
            require LWP::UserAgent;
            require HTTP::Cookies;
            1;
        };

        die "Unknown error, unable to load LWP::UserAgent and HTTP::Cookies"
            unless $loaded;
    }

    return;
}

## PKGBUILD TEMPLATES
##############################################################################

sub has_template
{
    my $distobj = shift;
    my $pkgname = $distobj->status->pkgname;

    return -f "$pkgname/PKGBUILD.tt";
}

# Creates a new template file that matches C::D::A's default in the current dir.
sub new_tt_file
{
    my ($dist_obj) = @_;

    my $pkgdir = $dist_obj->status->pkgname;
    mkdir $pkgdir unless ( -d $pkgdir );

    return unless confirm_overwrite( "$pkgdir/PKGBUILD.tt" );

    open my $templ_file, '>', "$pkgdir/PKGBUILD.tt"
        or die "open PKGBUILD.tt failed: $!";
    print $templ_file $TT_DIST_PREFIX, $dist_obj->parent->package_name, "\n";
    print $templ_file $dist_obj->get_pkgbuild_templ;
    close $templ_file or die "close PKGBUILD.tt failed: $!";
}

# Take a PKGBUILD in current dir and create a template out of it for future versions...
sub pkgbuild_to_tt
{
    # Handle missing or existing files...
    die "ERROR There is no PKGBUILD in current directory that we can reverse
into a template" unless ( -f 'PKGBUILD' );

    return unless confirm_overwrite( 'PKGBUILD.tt' );

    my $pkgbuild_txt = do { local (@ARGV, $/) = 'PKGBUILD'; <> };

    # Find the distribution name so we can look it up when we convert the template
    # to the PKGBUILD...
    my ($distname) =
        $pkgbuild_txt =~ m{^ source = \s* [^\n]* / ( [-\w]+ ) -\d }xms;
    
    die "ERROR failed to determine the distribution name from the existing PKGBUILD\n"
        unless ( $distname );

    # Replace all bash variables values we can with template values...
    my @var_names = qw{ pkgname pkgver pkgdesc url source md5sums source };
    my $var_match = join '|', @var_names;

    $pkgbuild_txt =~ s{($var_match) = \s* ["]    .*? [^\\] ["]    }
                      {$1="\[% $1 \%]"}gxms;
    $pkgbuild_txt =~ s{($var_match) = \s* [']    .*?       [']    }
                      {$1='\[% $1 \%]'}gxms;
    $pkgbuild_txt =~ s{($var_match) = \s* [(]['] .*?       ['][)] }
                      {$1=('\[% $1 \%]')}gxms;
    $pkgbuild_txt =~ s{($var_match) = \s* [(]["] .*? [^\\] ["][)] }
                      {$1=("\[% $1 \%]")}gxms;

    # Depends are different, remove the quotes from inside the parenthesis.
    # Also try to preserve non-perl dependencies...
    $pkgbuild_txt =~ s{ ^depends = \s* [(] (.*?) [)] }
                      { q{depends=([% depends %] }
                        . ( join q{ }, grep { !/perl/ } split /\s+/, $1 )
                        . q{)} }xmse;

    # Also replace _DISTDIR or DIST_DIR if we are creating a template from
    # a C::D::A generated PKGBUILD...
    $pkgbuild_txt =~ s{(DIST|_DIST)DIR=".*?"}{DIST_DIR="\${srcdir}/[% distdir %]"};
    $pkgbuild_txt =~ s{\$_DISTDIR}{\$DIST_DIR}g;
    # Change _DISTDIR for backwards compatibility...

    open my $templ_file, '>', 'PKGBUILD.tt' or die "open PKGBUILD.tt: $!";
    print $templ_file $TT_DIST_PREFIX, $distname, "\n";
    print $templ_file $pkgbuild_txt;
    close $templ_file;

    msg "Reverse-engineered PKGBUILD to PKGBUILD.tt successfully\n";

    return;
}

# Fills a template and prints it to a PKGBUILD file.
# Returns: A CPANPLUS::Dist::Arch object of the PKGBUILD's package.
sub tt_to_pkgbuild
{
    return unless confirm_overwrite( 'PKGBUILD' );

    open my $templ_file, '<', 'PKGBUILD.tt' or die "open PKGBUILD.tt: $!";
    my ($distname) = ( scalar <$templ_file> ) =~ /^$TT_DIST_PREFIX(.*)$/;
    die qq{ERROR "$TT_DIST_PREFIX" line is missing from the PKGBUILD.tt template\n}
        unless $distname;
    
    my $templ_text = do { local $/; <$templ_file> };
    close $templ_file or die "close PKGBUILD.tt: $!";

    my $cb      = CPANPLUS::Backend->new();
    my $modobj  = $cb->parse_module( module => $distname );
    my $distobj = create_dist_arch( $modobj => 'prepare' );

    $distobj->set_pkgbuild_templ( $templ_text );
    $distobj->create_pkgbuild( q{.} );

    return $distobj;
}

## SCRIPT START
##############################################################################

if ( $REVERSE ) {
    pkgbuild_to_tt();
    exit 0;
}

UPLOAD_CMD:
if ( defined $UPLOAD && !@ARGV ) {
    load_web_modules();

    # A string argument was given to the -upload switch, is it a directory,
    # file, or module?  Try to DWIM.

    if ( length $UPLOAD > 0 ) {
        if ( -d $UPLOAD ) {
            # Hopefully this is a package directory...
            chdir $UPLOAD;
        }
        elsif ( $UPLOAD =~ /[.]src[.]tar[.]gz$/ && -f $UPLOAD ) {
            upload_to_aur( $UPLOAD );
            exit 0;
        }
        else {
            push @ARGV, $UPLOAD;
            goto PARSE_MODS;
        }
    }

    # Without any arguments, work on the current directory as if it is
    # a source package directory...

    # Convert template to PKGBUILD if one exists in the directory.
    tt_to_pkgbuild() if ( -f 'PKGBUILD.tt' );

    die <<'END_ERR' unless ( -f 'PKGBUILD' );
There is no PKGBUILD in the directory and no module names
specified on the command line.  Cannot upload anything.
END_ERR

    my $make_cmd = 'makepkg --source --force --clean';
    my $output   = `$make_cmd`;

    # We can only parse the output of makepkg to find the filename...
    my @pkginfo = $output =~ /Making package: ([\w-]+) ([\d.-]+)/
        or die "ERROR makepkg returned unknown output";

    my $pkgfile = ( join '-', @pkginfo ) . '.src.tar.gz';

    upload_to_aur( $pkgfile );
    exit 0;
}

pod2usage( -verbose => 0 ) unless ( @ARGV );

PARSE_MODS:
my $cb = CPANPLUS::Backend->new;

MODULE_ARG:
for my $modname ( @ARGV ) {
    my $modobj = $cb->module_tree( $modname );

    msg( "Finding module $modname... " );

    unless ( $modobj ) {
        msg( "failed!\n" );
        msg( *STDERR, "cpan2aur: Failed to find a module named $modname\n" );
        next MODULE_ARG;
    }

    msg( "done\n" );

    if ( $TEMPLATE ) {
        my $distobj = create_dist_arch( $modobj => 'prepare' )
            or die "failed to prepare module";

        new_tt_file( $distobj );
        next MODULE_ARG;
    }

    if ( $DIRECTORY ) {
        my $distobj = create_dist_arch( $modobj => 'prepare' )
            or die "failed to prepare module";

        create_aurpkgdir( $distobj );
        next MODULE_ARG;
    }

    msg( "Creating source package file... " );
    my $distobj = create_dist_arch( $modobj => 'create' );
    if ( $UPLOAD ) {
        load_web_modules();

        my $srcpkg_fqp = $distobj->status->dist;
        msg( $srcpkg_fqp );
    }
}

__END__

=head1 NAME

cpan2aur - AUR Utility for CPAN perl modules

=head1 SYNOPSIS

cpan2aur [-qvfdtu] Module::Name [ Module::Name, ... Module::Name ]

cd <package-directory>; cpan2aur [-r or -u]

 -h, --help            Brief help message.
 -m, --man             Full help manpage.
 -q, --quiet           Quiet mode.  Supress our own messages.
                       Answers the default to any questions.
 -v, --verbose         Allow CPANPLUS to be verbose (spammy).
                       May be useful for debugging.
 -f, --force           Overwrite files without confirming.

 -d, --directory       Create a source package directory with a PKGBUILD.
 -t, --template        Create a source package directory with a default
                       PKGBUILD.tt template file.
 -r, --reverse         Convert a PKGBUILD in the current directory to a
                       template file (PKGBUILD.tt).
 -u, --upload  [dir]   Upload the generated source package to the AUR.
              [file]   * If a dir is specified cd to that dir and...
            [module]     convert PKGBUILD.tt (optional) to PKGBUILD to
                         source package, then upload it.
                       * If a file is specified, upload it if it appears
                         to be a source package.
                       * If a module is specified, makepkg and upload it.
                       * If nothing is specified, act as if the current
                         directory was given as an argument.

 (Unlike GNU options, single-letter options need their own hyphens
  example: -u -d)

=head1 DESCRIPTION

This is a utility made for creating and uploading perl packages for
the AUR (Archlinux User Repository).  cpan2aur's simplest usage
creates AUR source packages in the current directory.

With the I<-d> or I<--directory> flags cpan2aur will create a
directory to contain the source package and generate a C<PKGBUILD>
inside it.

With the I<-u> or I<--upload> flag it will upload a source package to
the AUR.  It will try to Do The Right Thing (tm) for uploading.  We
store previous logins inside the file C<~/.cpan2aur>.  The last username
that was used will be retried.  To specify a new name use the I<-n> or
I<--name> flag.

=over

=item 1. If an argument is given to I<-u> then just try uploading that file.
         (It must end in .pkg.tar.gz, though)

=item 2. If we are inside a source package directory (with a PKGBUILD),
         try to run 'makepkg' and then uplaod the resulting file.

=item 3. Otherwise, create a vanilla .pkg.tar.gz file and then upload it.

=back

=head1 EXAMPLE

Here is how to use the directory and upload features in your AUR
packaging workflow:

 cpan2aur -d ALPM     ( 1. We create a source package dir )
 cd perl-alpm         ( 2. Enter it                       )
 ed PKGBUILD          ( 3. Tweak the PKGBUILD a bit       )
 cpan2aur -u          ( 4. Run makepkg and upload!        )
                      ( 5. Profit!                        )

=head1 SEE ALSO

L<http://aur.archlinux.org>

=head1 AUTHOR

Justin Davis C<< <juster at cpan dot org> >>

=head1 COPYRIGHT & LICENSE

Copyright 2010 Justin Davis, all rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut
