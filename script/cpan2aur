#!/usr/bin/perl

use warnings;
use strict;

use File::Spec::Functions qw(catfile splitpath);
use CPANPLUS::Backend;
use Term::ReadLine;
use Getopt::Long;
use English qw(no_match_vars);
use Pod::Usage;
use 5.010;
use Cwd;

use LWP::UserAgent;
use HTTP::Cookies;

eval { require CPANPLUS::Dist::Arch; 1; }
    or die <<END_ERR;
cpan2aur: CPANPLUS::Dist::Arch must be installed for this script to work.
END_ERR

## CONSTANTS
##############################################################################

sub PKGBUILD_ERRCODE() { 2 }
sub TOOQUIET_ERRCODE() { 3 }

# should just make these scalars, too... hrmph
sub AUR_LOGIN_URI()    { 'http://aur.archlinux.org/' }
sub AUR_UPLOAD_URI()   { 'http://aur.archlinux.org/pkgsubmit.php' }
sub COOKIE_NAME()      { 'AURSID' }
sub CAT_LIB()          { 10 };

my $BAD_LOGIN_MSG  = 'Bad username or password.';
my $NEED_LOGIN_MSG = 'You must create an account before you can upload packages.';
my $PKG_EXISTS_MSG = qr{You are not allowed to overwrite the <b>.*?</b> package.};
my $CFGPATH        = "$ENV{HOME}/.cpan2aur";

my $NEED_LOGIN_ERR = "ERROR\nLogin session was invalid.\n";
my $PKG_EXISTS_ERR = "ERROR\nYou tried to submit a package you do not own.\n";

## COMMAND LINE ARGUMENTS
##############################################################################

my ($DIRECTORY, $VERBOSE, $UPLOAD, $QUIET, $FORCE, $HELP, $MAN, $NAME,
    $TEMPLATE, $REVERSE);

GetOptions( 'directory' => \$DIRECTORY,
            'template'  => \$TEMPLATE,
            'verbose'   => \$VERBOSE,
            'reverse'   => \$REVERSE,
            'upload'    => \$UPLOAD,
            'force'     => \$FORCE,
            'quiet'     => \$QUIET,
            'man'       => \$MAN,
            'help'      => \$HELP,
           );

pod2usage( -message => 'We cannot be both verbose and quiet!',
           -verbose => 0,
           -retval  => 1 ) if ( $VERBOSE && $QUIET);

pod2usage( -verbose => 1 ) if ( $HELP );
pod2usage( -verbose => 0 ) unless ( @ARGV );

## AUR PACKAGE BUILDING
##############################################################################

sub msg
{
    return if $QUIET;

    if ( @_ == 2 ) {
        my $fh = shift;
        print $fh @_;
        return;
    }

    print @_;
}

# Check if a file exists, if so offer to delete it.
# Return 1 if the file doesn't exist or it does and was deleted.
#        0 if the file existed and the user wanted to keep it.
sub confirm_overwrite
{
    my ($file_path) = @_;

    return 1 unless ( -f $file_path );

    # User wants us to force deletions...
    if ( $FORCE ) {
        unlink $file_path or die qq{failed to "rm $file_path": $!};
        return 1;
    }

    exit PKGBUILD_ERRCODE if $QUIET; # exit program with error if we're quiet

    # Keep asking until we get a yes, no, or blank answer...
    USER_QUESTION:
    {
        my $rl = Term::ReadLine->new( 'cpan2aur' );
            
        print "$file_path already exists, overwrite? [y/N] ";
        my $answer = $rl->readline;
        
        $answer ||= q{n};
        redo USER_QUESTION unless $answer =~ /\A[yn]/i;
 
        return 0 if $answer =~ /\An/i;
    }

    msg( "Overwriting $file_path... " );
    unlink $file_path or die qq{failed to "rm $file_path": $!};
    msg( "ok\n" );
    return 1;
}

sub check_pkgdir_file
{
    my ($distobj, $pkgfile) = @_;
    my $pkgdir    = $distobj->status->pkgname;
    my $file_path = "$pkgdir/$pkgfile";

    if ( -f $file_path ) {
        # If the pkgfile already exists, offer to overwrite.
        return 0 unless confirm_overwrite( $file_path );
    }
    else {
        unless ( -d $pkgdir ) {
            mkdir $pkgdir or die qq{failed to "mkdir $file_path": $!};
        }
        msg( "Creating $file_path.\n" );
    }

    return 1;
}

sub create_aurpkgdir
{
    my $dist_obj = shift;
    my $pkgname = $dist_obj->status->pkgname;

    return unless check_pkgdir_file( $dist_obj, 'PKGBUILD' );
    
    $dist_obj->create_pkgbuild( $pkgname );
    return;
}

sub create_dist_arch
{
    my ($mod_obj, $target) = @_;
    my $v = !$QUIET && $VERBOSE;

    $mod_obj->fetch( verbose => $v ) && $mod_obj->extract( verbose => $v )
        or return 0;

    my ($stdout_dup, $stderr_dup);
    if ( $QUIET ) {
        # prepare() does not honor our 'verbose' argument.
        # dist() does not pass our 'verbose' argument to create().
        # time to get serious about begin quiet!
        open $stdout_dup, '>&STDOUT' or die "duping STDOUT: $!";
        open $stderr_dup, '>&STDERR' or die "duping STDOUT: $!";
        close STDOUT;
        close STDERR;
    }

    return $mod_obj->dist( target  => $target,
                           format  => 'CPANPLUS::Dist::Arch',
                           args    => { verbose => $v,
                                        pkg     => 'src',
                                        destdir => getcwd() } );

    if ( $QUIET ) {
        open STDOUT, ">&", $stdout_dup or die "resuming STDOUT: $!";
        open STDERR, ">&", $stderr_dup or die "resuming STDERR: $!";
    }
}

## AUR PACKAGE UPLOAD
##############################################################################

sub load_last_login
{
    return () unless ( -e $CFGPATH );

    die q{Please 'chmod 600 ~/.cpan2aur', it is not readable}
        unless ( -r $CFGPATH );

    open my $cfgfile, '<', $CFGPATH or die "open $CFGPATH: $!";
    my ($user, $sid) = split ':', <$cfgfile>;
    close $cfgfile;

    return () unless ( $user && $sid && $sid =~ /^[A-F0-9]+$/m );

    chomp $sid;
    return ($user, $sid);
}

sub save_last_login
{
    my ($username, $sid) = @_;

    # Set umask to keep this file private...
    my ($oldmask, $found) = (umask 0077, 0);
    $username = lc $username;

    open my $cfgfile, '>', $CFGPATH or die "open $CFGPATH: $!";
    print $cfgfile "$username:$sid\n";
    close $cfgfile or die "close $CFGPATH: $!";

    umask $oldmask;
    return;
}

sub new_login_sid
{
    my ($ua, $username, $passwd) = @_;

    # Get a fresh session ID cookie...
    $ua->cookie_jar( HTTP::Cookies->new() );
    my $resp = $ua->post( AUR_LOGIN_URI,
                          [ user        => $username,
                            passwd      => $passwd,
                            remember_me => 1, # probably not needed
                           ] );

    # Check for problems...
    die "Bad username or password\n"
        if ( $resp->content =~ /$BAD_LOGIN_MSG/ );

    die "Error with AUR login, expected status code 302.\nGot status: ",
        $resp->status_line if !( $resp->code == 302  && !$resp->is_success );

    my $sid;
    $ua->cookie_jar()->scan( sub { $sid = $_[2] if $_[1] eq COOKIE_NAME; } );

    die "ERROR Login did not supply us with an AURSID cookie\n"
        unless ( $sid );

    return $sid;
}

sub mk_session_cookie
{
    my ($sid) = @_;

    my %cookies = ( COOKIE_NAME() => $sid,
                    AURLANG       => 'en', );

    my $cookie_obj = HTTP::Cookies->new();
    for my $name ( keys %cookies ) {
        $cookie_obj->set_cookie( q{}, $name, $cookies{$name},
                                 q{/}, 'aur.archlinux.org' );
    }

    return $cookie_obj;
}

sub post_upload
{
    my ($ua, $pkg_path) = @_;

    my $resp = $ua->post( AUR_UPLOAD_URI,
                          'Content-Type' => 'form-data',
                          'Content'      => [ category  => CAT_LIB(),
                                              submit    => 'Upload',
                                              pkgsubmit => 1,
                                              pfile     => [ $pkg_path ],
                                             ] );

    # We get a 302 Moved HTTP status code on success and when uploading a package
    # that we own if the package file is older and ignored...
    return if ( $resp->code() == 302 );
    
    die "Error when uploading file, got http status ", $resp->status_line
        unless ( $resp->is_success );

    die $NEED_LOGIN_ERR if ( $resp->content =~ /$NEED_LOGIN_MSG/ );
    die $PKG_EXISTS_ERR if ( $resp->content =~ /$PKG_EXISTS_MSG/ );
}

sub prompt
{
    exit TOOQUIET_ERRCODE if $QUIET;
    return Term::ReadLine->new( 'cpan2aur' )->readline( shift );
}

sub upload_to_aur
{
    my ($pkg_path) = @_;
    local $OUTPUT_AUTOFLUSH = 1;

    msg "Uploading $pkg_path to AUR...\n";

    my ($username, $sid) = load_last_login();
    $username ||= prompt( 'Username:' );
    my $ua      = LWP::UserAgent->new();

    # First try to reuse an old Session ID...
    if ( $sid ) {
        msg( "Sending package as $username... " );
        $ua->cookie_jar( mk_session_cookie( $sid ));
        eval { post_upload( $ua, $pkg_path ) };
        unless ( $EVAL_ERROR ) {
            msg( "ok\n" );
            return;
        }

        # Fall through to get a new session ID if we just need to re-login...
        die $@ unless ( $EVAL_ERROR =~ /$NEED_LOGIN_ERR/ );

        msg( "old session ID failed. Starting new session.\n" );
    }

    my $passwd = prompt( 'Password:' );

    # Retrieve a new session and save it...
    $sid = new_login_sid( $ua, $username, $passwd );
    save_last_login( $username, $sid );
    msg( "ok\n" );

    msg( "Sending package as $username... " );
    post_upload( $ua, $pkg_path );
    msg( "ok\n" );

    return;
}

## PKGBUILD TEMPLATES
##############################################################################

sub has_template
{
    my $distobj = shift;
    my $pkgname = $distobj->status->pkgname;

    return -f "$pkgname/PKGBUILD.tt";
}

# Creates a new template file that matches C::D::A's default in the current dir.
sub new_tt_file
{
    my ($dist_obj) = @_;

    return unless confirm_overwrite( 'PKGBUILD.tt' );

    my $pkgdir = $dist_obj->status->pkgname;
    open my $templ_file, '>', "$pkgdir/PKGBUILD.tt"
        or die "open PKGBUILD.tt failed: $!";

    print $templ_file $dist_obj->get_pkgbuild_templ;
    close $templ_file or die "close PKGBUILD.tt failed: $!";
}

# Take a PKGBUILD in current dir and create a template out of it for future versions...
sub pkgbuild_to_tt
{
    # Handle missing or existing files...
    die "ERROR There is no PKGBUILD in current directory that we can reverse
into a template" unless ( -f 'PKGBUILD' );
    return unless confirm_overwrite( 'PKGBUILD.tt' );

    # Replace all bash variables values we can with template values...
    my $pkgbuild_txt = do { local (@ARGV, $/) = 'PKGBUILD'; <> };

    my @var_names = qw{ pkgname pkgver pkgdesc depends url source md5sums source };
    my $var_match = join '|', @var_names;

    $pkgbuild_txt =~ s{($var_match) = \s* ["]    .*? [^\\] ["]    }
                      {$1="\[% $1 \%]"}gxms;
    $pkgbuild_txt =~ s{($var_match) = \s* [']    .*?       [']    }
                      {$1='\[% $1 \%]'}gxms;
    $pkgbuild_txt =~ s{($var_match) = \s* [(]['] .*?       ['][)] }
                      {$1=('\[% $1 \%]')}gxms;
    $pkgbuild_txt =~ s{($var_match) = \s* [(]["] .*? [^\\] ["][)] }
                      {$1=("\[% $1 \%]")}gxms;

    # Also replace _DISTDIR or DIST_DIR if we are creating a template from
    # a C::D::A generated PKGBUILD...
    $pkgbuild_txt =~ s{(DIST|_DIST)DIR=".*?"}{DIST_DIR="\${srcdir}/[% distdir %]"};
    $pkgbuild_txt =~ s{\$_DISTDIR}{\$DIST_DIR}g;
    # Change _DISTDIR for backwards compatibility...

    open my $templ_file, '>', 'PKGBUILD.tt' or die "open PKGBUILD.tt: $!";
    print $templ_file $pkgbuild_txt;
    close $templ_file;

    msg "Reverse-engineered PKGBUILD to PKGBUILD.tt successfully\n";

    return;
}

# Fills a template and prints it to a PKGBUILD file.
sub tt_to_pkgbuild
{
    my ($distobj) = @_;

    return unless confirm_overwrite( 'PKGBUILD' );

    open my $templ_file, '<', 'PKGBUILD.tt' or die "open PKGBUILD.tt: $!";
    my $templ_text = do { local $/; <$templ_file> };
    close $templ_file or die "close PKGBUILD.tt: $!";

    $distobj->set_pkgbuild_templ( $templ_text );
    $distobj->create_pkgbuild( q{.} );
    return;
}

## SCRIPT START
##############################################################################

my $cb = CPANPLUS::Backend->new;

MODULE_ARG:
for my $modname ( @ARGV ) {
    my $modobj = $cb->module_tree( $modname );

    msg( "Finding module $modname... " );

    unless ( $modobj ) {
        msg( "failed!\n" );
        msg( *STDERR, "cpan2aur: Failed to find a module named $modname\n" );
        next MODULE_ARG;
    }

    msg( "done\n" );

    if ( $DIRECTORY ) {
        my $distobj = create_dist_arch( $modobj => 'prepare' )
            or die "failed to prepare module";

        create_aurpkgdir( $distobj );
        next MODULE_ARG;
    }

    msg( "Creating source package file... " );
    my $distobj = create_dist_arch( $modobj => 'create' );
    if ( $UPLOAD ) {
        my $srcpkg_fqp = $distobj->status->dist;
        msg( $srcpkg_fqp );
    }
}

__END__

=head1 NAME

cpan2aur - AUR Utility for CPAN perl modules

=head1 SYNOPSIS

cpan2aur [-qvfdtu] Module::Name [ Module::Name, ... Module::Name ]

cd <package-directory>
cpan2aur [-r or -u]

 -h, --help            Brief help message.
 -m, --man             Full help manpage.
 -q, --quiet           Quiet mode.  Supress our own messages.  Answers
                       the default to any questions.
 -v, --verbose         Allow CPANPLUS to be verbose (spammy).
                       May be useful for debugging.
 -f, --force           Overwrite files without confirming.

 -d, --directory       Create a source package directory with a PKGBUILD.
 -t, --template        Create a source package directory with a PKGBUILD.tt
                       template file.
 -r, --reverse         Convert a PKGBUILD in the current directory to a template
                       (a PKGBUILD.tt file).
 -u, --upload          Upload the generated source package to the AUR.
                       * If no module is specified on the command line
                         and a PKGBUILD exists in our current directory,
                         run makepkg and then upload that source package.
                         (see example in cpan2aur --help)
                         + If a PKGBUILD.tt exists instead, generate a
                           PKGBUILD from that instead.

(Unlike GNU options, single-letter options need their own hyphen, ie: -u -d)

=head1 DESCRIPTION

This is a utility made for creating and uploading perl packages for
the AUR (Archlinux User Repository).  cpan2aur's simplest usage
creates AUR source packages in the current directory.

With the I<-d> or I<--directory> flags cpan2aur will create a
directory to contain the source package and generate a C<PKGBUILD>
inside it.

With the I<-u> or I<--upload> flag it will upload a source package to
the AUR.  It will try to Do The Right Thing (tm) for uploading.  We
store previous logins inside the file C<~/.cpan2aur>.  The last username
that was used will be retried.  To specify a new name use the I<-n> or
I<--name> flag.

=over

=item 1. If an argument is given to I<-u> then just try uploading that file.
         (It must end in .pkg.tar.gz, though)

=item 2. If we are inside a source package directory (with a PKGBUILD),
         try to run 'makepkg' and then uplaod the resulting file.

=item 3. Otherwise, create a vanilla .pkg.tar.gz file and then upload it.

=back

=head1 EXAMPLE

Here is how to use the directory and upload features in your AUR
packaging workflow:

 cpan2aur -d ALPM     ( 1. We create a source package dir )
 cd perl-alpm         ( 2. Enter it                       )
 ed PKGBUILD          ( 3. Tweak the PKGBUILD a bit       )
 cpan2aur -u          ( 4. Run makepkg and upload!        )
                      ( 5. Done                           )

=head1 SEE ALSO

L<http://aur.archlinux.org>

=head1 AUTHOR

Justin Davis, C<< <jrcd83 gmail> >>, juster on L<http://bbs.archlinux.org>

=head1 COPYRIGHT & LICENSE

Copyright 2010 Justin Davis, all rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut
